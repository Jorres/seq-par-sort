## Практическое задание 1, seq-par qsort

Весь код находится в одном файле - main.go.

#### Если у вас есть go

Чтобы запустить, нужно выполнить:

```
GOMAXPROCS=4 go run main.go
```

Убедиться, что GOMAXPROCS=4 действительно не дает сожрать больше 400% cpu, можно 

#### Если у вас нет go

Я залил в репозиторий бинарничек, будем надеяться, что у вас тоже linux amd64:

```
GOMAXPROCS=4 ./seq-par-sort
```

#### Если у вас нет go и не запустился бинарничек

Извините! Вам придется поверить мне на слово, мне больше не на чем собрать под рукой :(

## Полезная информация

Две осмысленные функции: qsortPar и qsortSeq.

Так как мы на практике, а не на теории, нужно минимизировать несколько практических накладных расходов.

1. Чтобы минимизировать расходы на форки, перестаем форкаться, когда доходим до размера блока в 2000.
2. Чтобы минимизировать расходы на рекурсию, запускаем однопоточную сортировку пузырьком, когда доходим до размера блока в 10.
3. Вместо тупого вызова двух асинхронных функций после сплита в квиксорте (go func ..., go func ..., wait) я делаю вызов горутины,
а второй вызов делаю уже в существующем потоке. Без этой микрооптимизации на 5-6 процентов хуже время. 

Возможно, покрутив параметры из 1 и 2 еще немного, можно выжать еще больше.

## Результаты:

```
seq-par-qsort ❯ GOMAXPROCS=4 ./seq-par-qsort
Quicksort parallel with 1e+08 elements, averaged over 5 launches

Launch 1: 3.561190164s
Launch 2: 3.504097303s
Launch 3: 3.545705201s
Launch 4: 3.376103807s
Launch 5: 3.615054636s

Average time: 3.520430222s
Quicksort sequential with 1e+08 elements, averaged over 5 launches

Launch 1: 11.298794111s
Launch 2: 11.105049137s
Launch 3: 10.13664043s
Launch 4: 10.494955002s
Launch 5: 10.04549562s

Average time: 10.61618686s
```

Выигрыш: 10.61618686 / 3.520430222 = 3.01559360378.
