## Практическое задание 1, seq-par qsort

Весь код находится в одном файле - main.go.

#### Если у вас есть go

Чтобы запустить, нужно выполнить:

```
GOMAXPROCS=4 go run main.go
```

Убедиться, что GOMAXPROCS=4 действительно не дает сожрать больше 400% cpu, можно, открыв рядышком `top`.

#### Если у вас нет go

Я залил в репозиторий бинарничек, будем надеяться, что у вас тоже linux amd64:

```
GOMAXPROCS=4 ./seq-par-sort
```

#### Если у вас нет go и не запустился бинарничек

Извините! Вам придется поверить мне на слово, мне больше не на чем собрать под рукой :(

## Полезная информация

Две осмысленные функции: qsortPar и qsortSeq.

Так как мы на практике, а не на теории, нужно минимизировать несколько практических накладных расходов.

1. Чтобы минимизировать расходы на форки, перестаем форкаться, когда доходим до размера блока в 2000.
2. Чтобы минимизировать расходы на рекурсию, запускаем однопоточную сортировку пузырьком, когда доходим до размера блока в 10.
3. Вместо тупого вызова двух асинхронных функций после сплита в квиксорте (go func ..., go func ..., wait) я делаю вызов горутины,
а второй вызов делаю уже в существующем потоке. Без этой микрооптимизации на 5-6 процентов хуже время. 

Возможно, покрутив параметры из 1 и 2 еще немного, можно выжать еще больше.

## Результаты:

```
seq-par-qsort ❯ GOMAXPROCS=4 ./seq-par-qsort
Quicksort parallel with 1e+08 elements, averaged over 5 launches

Launch 1: 3.561190164s
Launch 2: 3.504097303s
Launch 3: 3.545705201s
Launch 4: 3.376103807s
Launch 5: 3.615054636s

Average time: 3.520430222s
Quicksort sequential with 1e+08 elements, averaged over 5 launches

Launch 1: 11.298794111s
Launch 2: 11.105049137s
Launch 3: 10.13664043s
Launch 4: 10.494955002s
Launch 5: 10.04549562s

Average time: 10.61618686s
```

Выигрыш: 10.61618686 / 3.520430222 = 3.01559360378.

## Update after deadline

По обсуждению в чате я понял, что нужно было еще и написать версию с filter\scan. Что ж, лучше поздно, чем никогда, поэтому выкладываю еще и ее.

Запуск:

```
GOMAXPROCS=4 go run main.go par.go
```

Результаты: (на 3 * 1e7 потому что у меня не хватило памяти на 1e8 :)

Видно, что нормально версию со сканами сделать не получилось :( 

```
Quicksort parallel just fork with 3e+07 elements, averaged over 5 launches

Launch 1: 1.100979769s
Launch 2: 1.075080866s
Launch 3: 1.069924883s
Launch 4: 1.070284812s
Launch 5: 1.032754069s

Average time: 1.069804879s
Quicksort parallel filter/flags with 3e+07 elements, averaged over 5 launches

Launch 1: 8.327654204s
Launch 2: 7.901150208s
Launch 3: 7.86835264s
Launch 4: 8.773543146s
Launch 5: 9.273885242s

Average time: 8.428917088s
Quicksort sequential with 3e+07 elements, averaged over 5 launches

Launch 1: 2.920410994s
Launch 2: 2.894015561s
Launch 3: 2.817156518s
Launch 4: 2.784574081s
Launch 5: 2.951704728s

Average time: 2.873572376s
```
